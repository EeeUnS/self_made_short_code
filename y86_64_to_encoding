
#pragma warning(disable : 4996)

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<cinttypes>
// Y86-64 -> 기계어 변환기


/*

halt 00
nop  10

rrmovq 20
cmovle 21
cmovl 2 2
cmove 2 3
cmovne 2 4
cmovge 2 5
cmovg 2 6

irmovq 30
rmmovq 40
mrmovq 50


addq 6 0
subq 6 1
andq 6 2
xorq 6 3

jmp 70
jle 71
jl 7 2
je 7 3
jne 7 4
jge 7 5
jg 7 6

call 80
ret 90
pushq A0
popq B0


"%rax",
	"%rcx",
	"%rdx",
	"%rbx",
	"%rsp",
	"%rbp",
	"%rsi",
	"%rdi",
	"%r8",
	"%r9",
	"%r10",
	"%r11",
	"%r12",
	"%r13",
	"%r14",
	"No register"

*/

enum Instruction
{
	halt = 0,
	nop,
	//20

	rrmovq,
	cmovle,
	cmovl,
	cmove,
	cmovne,
	cmovge,
	cmovg,


	irmovq,
	rmmovq,
	mrmovq,


	//60
	addq,
	subq,
	andq,
	xorq,

	//70
	jmp,
	jle,
	jl,
	je,
	jne,
	jge,
	jg,


	//80
	call,
	ret,
	pushq,
	popq

};

const char* instruction[] =
{
	"halt",
	"nop",

	"rrmovq",
	"cmovle",
	"cmovl",
	"cmove",
	"cmovne",
	"cmovge",
	"cmovg",

	"irmovq",
	"rmmovq",
	"mrmovq",


	"addq",
	"subq",
	"andq",
	"xorq",

	"jmp" ,
	"jle" ,
	"jl" ,
	"je" ,
	"jne" ,
	"jge" ,
	"jg" ,

	"call",
	"ret",
	"pushq",
	"popq"
};

const int Instruction_Encoding[]
{
	0x00,
	0x10,
	0x20,
	0x21,
	0x22,
	0x23,
	0x24,
	0x25,
	0x26,

	0x30,
	0x40,
	0x50,

	0x60,
	0x61,
	0x62,
	0x63,

	0x70,
	0x71,
	0x72,
	0x73,
	0x74,
	0x75,
	0x76,

	0x80,
	0x90,
	0xA0,
	0xB0,
};

//register specifier
const char* reg[] =
{
	"%rax",
	"%rcx",
	"%rdx",
	"%rbx",
	"%rsp",
	"%rbp",
	"%rsi",
	"%rdi",
	"%r8",
	"%r9",
	"%r10",
	"%r11",
	"%r12",
	"%r13",
	"%r14",
	"No register"
};

char* Label[20][20];

void insrtruction_to_encoding();
void input_error();
uint64_t little_endian(uint64_t integer);
void Print_Encoding_Instruction(int number);
int find_reg(char reg[]);
void reg_in();

int address = 0x100;

int main()
{
	while (!feof(stdin))
	{
		insrtruction_to_encoding();
	}
	return 0;

}

void insrtruction_to_encoding()
{
	char __instruction[10] = { 0, };
	const int buffer = 10;
	scanf_s("%s", __instruction, sizeof(__instruction));

	int ins_len = strlen(__instruction);
	//__instruction[ins_len - 1] = '\0';
	int index = 28;
	for (int i = 0; i < 27; i++)
	{
		size_t len = strlen(instruction[i]);
		if (!strncmp(__instruction, instruction[i], len))//같을때 0반환
		{
			index = i;
			break;
		}
	}
	printf("0x%X: ", address);
	switch (index)
	{
	case halt:
	case nop:
	case ret: //90
		Print_Encoding_Instruction(index);
		printf("\n");
		address += 1;
		break;
		//20
	case rrmovq:
	case cmovle:
	case cmovl:
	case cmove:
	case cmovne:
	case cmovge:
	case cmovg:
		//60
	case addq:
	case subq:
	case andq:
	case xorq:
		Print_Encoding_Instruction(index);
		reg_in();
		reg_in();
		printf("\n");
		address += 2;
		break;
		//30
	case irmovq:
	{Print_Encoding_Instruction(index);
		printf("F");

		uint64_t D = 0;
		scanf_s("%" PRIx64, &D);
		D =little_endian(D);
		reg_in();
		printf("%" PRIX64 "\n", D);
		address += 10;
		break;
	}	//40
	case rmmovq:
	{	Print_Encoding_Instruction(index);
		reg_in(); //rA
		uint64_t D = 0;
		scanf_s("%" PRIx64, &D);
		printf("%" PRIx64, D);
		address += 10;
		break;
	}
	case mrmovq:
		Print_Encoding_Instruction(index);
		reg_in();



		address += 10;
		break;
		//70
	case jmp:
	case jle:
	case jl:
	case je:
	case jne:
	case jge:
	case jg:
		//80
	case call:
		//주소값을 저장해서 출력해야됨 씹헬
		Print_Encoding_Instruction(index);
		//Printf_destination

		address += 9;
		break;
	case pushq:
	case popq:
		Print_Encoding_Instruction(index);
		reg_in();
		printf("F\n");
		address += 2;
		break;
	default: //라벨 먼저 받든지 말든지
		break;
	}
}

void input_error()
{
	printf("input error");
	exit(-1);
	return;
}
//irmovq 0x12345678 %rdi
uint64_t little_endian(uint64_t integer)
{
	uint64_t num = integer;
	uint64_t intreturn = 0;
	uint64_t a = 0xFF;

	for (int i = 0; i < 4; i++)
	{
		intreturn = intreturn << 8;
		intreturn += num & a;
		num = num >> 8;
	}
	return intreturn;
}

void Print_Encoding_Instruction(int number)
{
	if (number == halt)
	{
		printf("00");
		return;
	}

	printf("%X", Instruction_Encoding[number]);
	return;
}

int find_reg(char _reg[])
{
	int index = 0;
	for (; index <= 16; index++)
	{
		if (strcmp(_reg, reg[index]) == 0)
		{
			return index;
		}
	}
	input_error();
	return -1;
}

void reg_in() //한개로 생각하고 둘다 처리하자! 쉼표떼기 + 공백처리 오류 젤나기쉬운곳
{
	char line[10] = { 0, }; //라인을 읽어서 순수 reg만 추출해 _reg에 넣는다.
	char _reg[10] = { 0, };

	scanf_s("%s", line, 10);

	int line_i = 0;
	// 1 쉼표만 읽은경우 , 2 쉼표 포함해서 레지를 읽을 경우  
	//3. 레지뒤의 주석을 읽은 경우. 4. 맨뒤에 쉼표가 들어간경우.
	if (line[0] == ',' && line[1] == '\0')
	{
		scanf_s("%s", line, 10);
	}

	if (line[0] == ',' && line[1] == '\0')
	{
		input_error();
		return;
	}
	else if (line[0] == ',')
	{
		line_i++;
	}

	int reg_index = 0;//입력이 제대로 되지않을시 에러
	for (; (!isspace(line[line_i])) && (line[line_i] != '#') && (line[line_i] != ',') && (line[line_i] != '\0'); line_i++, reg_index++)
	{
		_reg[reg_index] = line[line_i];
	}
	int reg_encoding = find_reg(_reg);
	printf("%X", reg_encoding);
}
